"use strict";
Object.defineProperty(exports, "__esModule", {value: true});
exports.capped_dense_wind_g_for_p_to_e = exports.dense_wind_g_for_p_to_e =
    exports.wind_g_for_p_to_e = exports.range = void 0;

function* range(start, stop) {
    let ii = start;
    while (ii < stop) {
        yield ii
        ii = ii + 1
    }
}

exports.range = range;

function* wind_g_for_p_to_e(g, p, e) {
    let ii = 0;
    let x = g;
    let p_to_e = Math.pow(p, e);
    let end = (p - 1) * Math.pow(p, e-1);
    for (ii of range(0, end )) {
        yield x
        x = (x * g) % p_to_e
    }
}

exports.wind_g_for_p_to_e = wind_g_for_p_to_e;

function* dense_wind_g_for_p_to_e(g, p, e) {
    const outer = [p];
    const inner = [p - 1];
    let ii = 0;
    for (ii of range(0, e - 1)) {
        outer.push(outer[ii] * p);
        inner.push(inner[ii] * p);
    }
    let x = 0;
    for (x of wind_g_for_p_to_e(g, p, e)) {
        ii = e - 1;
        let adj_x = 0;
        let remainder = 0;
        while (ii >= 0) {
            remainder = (x % outer[ii]);
            adj_x = adj_x + (((x - remainder) / outer[ii]) * inner[ii]);
            x = remainder;
            ii = ii - 1;
        }
        yield (adj_x + remainder)
    }
}

exports.dense_wind_g_for_p_to_e = dense_wind_g_for_p_to_e;

/**
 * Requests a generator for a prime power ring ordered sequence of integers ranging
 * from [1, cap].  This is implemented by discarding all values in the range [cap+1, max],
 * so is most efficient when the density of the prime power ring is greater than cap
 * by as small a margin as possible.  However, that density must be at least as great
 * as cap or the sequence is undefined and will yield an exception when requested.
 *
 * @param cap
 * @param g
 * @param p
 * @param e
 * @returns {Generator<*|number, void, *>}
 */
function* capped_dense_wind_g_for_p_to_e(cap, g, p, e) {
    let n = ((p - 1) * Math.pow(p, e - 1));
    if (cap > n) {
        throw IllegalArgumentError(`Insufficient ring size.  Capacity(${cap}) is > RingMax(${n})`);
    }
    let x = 0;
    for (x of dense_wind_g_for_p_to_e(g, p, e)) {
        if (x <= cap) {
            yield(x);
        }
    }
}

exports.capped_dense_wind_g_for_p_to_e = capped_dense_wind_g_for_p_to_e;